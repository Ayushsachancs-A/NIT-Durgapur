
# üß† Java Constructor Chaining ‚Äì Calling Parameterized Constructor from Default Constructor

## üîç Concept Overview

In Java, you can **call one constructor from another** within the same class using the keyword **`this()`**.  
However, there are strict rules about how and when this call can happen.

---

## ‚úÖ Rule

- You can call **one constructor from another** using `this()` or `this(arguments)`.
- The call to another constructor **must be the first statement** in the calling constructor.
- You **cannot** create a **circular call** (where constructors call each other endlessly).

---

## üìò Your Example Code

```java
package com.one;

public class ConstructorOverloadingDemo {
    public static void main(String[] args) {
        // Book book1 = new Book();
        Book book2 = new Book("Java Fundamentals", 499.99);
        // book1.Display();
        book2.Display();
    }
}

class Book {
    String title;
    double price;

    Book() {
        title = "unknown";
        price = 0.0;
        System.out.println("Book : " + title + ", Price : " + price);
    }

    Book(String title, double price) {
        this(); // ‚úÖ calls default constructor first
        this.title = title;
        this.price = price;
    }

    void Display() {
        System.out.println("Book: " + title + ", Price: " + price);
    }
}
```

### üßæ Output
```
Book : unknown, Price : 0.0
Book: Java Fundamentals, Price: 499.99
```

‚úÖ **Explanation:**
- The parameterized constructor calls `this()` ‚Üí executes default constructor.
- Default constructor prints the initial values.
- Then the parameterized constructor updates `title` and `price`.

---

## ‚ùå Invalid Case ‚Äì Infinite Recursion Example

You **cannot** have both constructors calling each other.  
The below example creates an infinite loop:

```java
class Book {
    Book() {
        this("unknown", 0.0); // ‚ùå calls parameterized constructor
    }

    Book(String title, double price) {
        this(); // ‚ùå calls default constructor again ‚Üí infinite loop
    }
}
```

### ‚ùó This causes:
`StackOverflowError` (infinite constructor chaining)

---

## ‚úÖ Correct Example ‚Äì Default Calls Parameterized

```java
class Book {
    String title;
    double price;

    // Default constructor calls parameterized constructor
    Book() {
        this("unknown", 0.0); // ‚úÖ safe constructor chaining
    }

    Book(String title, double price) {
        this.title = title;
        this.price = price;
    }

    void Display() {
        System.out.println("Book: " + title + ", Price: " + price);
    }
}
```

### üßæ Output:
```
Book: unknown, Price: 0.0
Book: Java Fundamentals, Price: 499.99
```

---

## üßÆ Summary Table

| From Constructor | Can Call | Using | Notes |
|------------------|-----------|--------|--------|
| Default ‚Üí Parameterized | ‚úÖ | `this(args)` | Common and safe |
| Parameterized ‚Üí Default | ‚úÖ | `this()` | Allowed but only if no circular reference |
| Both ways | ‚ùå | ‚Äî | Leads to infinite recursion |

---

## üß† Key Takeaways

- `this()` ‚Üí calls another constructor **in the same class**.  
- `super()` ‚Üí calls the **parent class constructor**.  
- Constructor chaining improves **code reusability** and **readability**.  
- Ensure **no cyclic calls** between constructors.

---

### üß© Real-world Analogy
Think of constructors as **setup routines** for a product:

- The **default constructor** sets ‚Äúbasic configuration‚Äù.
- The **parameterized constructor** customizes it with specific features.
- Using `this()` lets you **reuse setup logic** efficiently without repeating code.

---

**Author:** ItTechGenie  
**Topic:** Java ‚Äì Constructor Overloading & Chaining  
**Filename:** `ConstructorChaining_Notes.md`
